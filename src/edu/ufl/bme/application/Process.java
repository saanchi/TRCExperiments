package edu.ufl.bme.application;

import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.File;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.Iterator;
import java.util.concurrent.atomic.AtomicInteger;

import edu.ufl.bme.parsing.TRParse;
import edu.ufl.bme.regexmatch.RegexEngine;

public class Process  {


	public TRParse tParse;
	public RegexEngine regex;
	double totSubLabels, precisionSubLabels, recallSubLabels;
	double totLabels, precisionLabels, recallLabels;
	double correctDetected, totDetected;
	// For calculation of precision and recall according to sub-label
	HashMap<String, AtomicInteger> countInputSublabel   = new HashMap<String, AtomicInteger>();
	HashMap<String, AtomicInteger> countRegexSublabel   = new HashMap<String, AtomicInteger>();
	HashMap<String, AtomicInteger> countCorrectSublabel = new HashMap<String, AtomicInteger>();
	
	// For calculation of precision and recall according to label
	HashMap<String, AtomicInteger> countInputLabel   = new HashMap<String, AtomicInteger>();
	HashMap<String, AtomicInteger> countRegexLabel   = new HashMap<String, AtomicInteger>();
	HashMap<String, AtomicInteger> countCorrectLabel = new HashMap<String, AtomicInteger>();
	
	public Process(){
		tParse = new TRParse();
		regex  = new RegexEngine();
		// Needed for the calculation of overall precision and recall
		totSubLabels = precisionSubLabels = recallSubLabels = 0.0;
		totLabels = precisionLabels = recallLabels = 0.0;
		correctDetected = totDetected =0;
	}
	
	/**
	 * Run the application in text mode
	 * @param sentence
	 * @return
	 */
	public String runTextMode( String sentence ){
		ArrayList<String> tagged = regex.runRegex(sentence);
		StringBuilder output = new StringBuilder();
		Iterator<String> itr = tagged.iterator();
		while( itr.hasNext()){
			output.append(itr.next() + "," );
		}
		return output.toString();
	}

	/**
	 * Run the application in file mode.
	 * Takes input the input file name on which to run the tagger and regex engine
	 * @throws IOException 
	 * 
	 */
	
	public void runFileMode( String inputFilePath, String fileName  ) throws IOException{
		// Create a tagged file 
		// Get file path 
		String arr[]  = inputFilePath.split(fileName); // Only for linux now. No windows
		String inputFileName  = arr[0] + "/"  + fileName;
		String taggedFileName = arr[0] + "/"  + "tagged.txt";
		String outputFileName = arr[0] + "/"  + "regex_output.txt";
		String resultFileName  = arr[0] + "/"  + "result.txt";
		// Run parser and tagger on input file
		tParse.tagFile(inputFileName, taggedFileName );
		// Run regex engine on tagged file
		regex.runRegexFile( taggedFileName, outputFileName );
		// Compare input sentences with the output of regex
		compareResults( inputFileName, outputFileName, resultFileName );
	}
	/**
	 * Update Input labels count
	 * @param category
	 * @param inputLabelMap
	 */
	public void updateInputLabelsCount( String category, HashMap<String,Boolean> inputLabelMap ){
		// For each label present put an entry in List.
		//Increase the count for precision/recall calculation
		String label11[]     = category.split( Constants.LABEL_DELIM );
		if( label11.length >= 1){
			for( int i=0; i<label11.length; i++ ){
				String label = label11[i].trim();
				if( label.isEmpty() || label.equals("-")) continue;
				totLabels++; 						// for overall recall calculation
				inputLabelMap.put( label, true);
				// update the count of the sub-label in the map
				if( countInputLabel.containsKey( label)){
					countInputLabel.get(label).incrementAndGet();
				}
				else{ 
					countInputLabel.put(label, new AtomicInteger(1));
				}
			}
		}
	}
	
	/**
	 * Update Input Sublabels count
	 * @param category
	 * @param inputLabelMap
	 */
	public void updateInputSubLabelsCount( String subCategory, HashMap<String,Boolean> inputSubLabelMap ){
		// For each sublabel present put an entry in List.
		//Increase the count for precision/recall calculation
		String subLabel11[]     = subCategory.split( Constants.LABEL_DELIM );
		if( subLabel11.length >= 1){
			for( int i=0; i<subLabel11.length; i++ ){
				String subLabel = subLabel11[i].trim();
				if( subLabel.isEmpty() || subLabel.equals("-")) continue;
				totSubLabels++; 						// for overall recall calculation
				inputSubLabelMap.put( subLabel, true);
				// update the count of the sub-label in the map
				if( countInputSublabel.containsKey( subLabel)){
					countInputSublabel.get(subLabel).incrementAndGet();
				}
				else{ 
					countInputSublabel.put(subLabel, new AtomicInteger(1));
				}
			}
		}
	}
	
	/**
	 * Update the total and correct count generated by regex engine for labels
	 * @param label
	 * @param inputLabelMap
	 */
	public void updateRegexLabelsCount( String category, HashMap<String, Boolean> inputLabelMap, 
										StringBuilder labelInputString, StringBuilder labelRegexString ){

		String label21[]  = category.split( Constants.LABEL_DELIM );
		// Check if label from regex file is same as input or not.
		if( label21.length >= 1){
			for( int i=0; i<label21.length; i++ ){
				String label = label21[i].trim();
				if( label.isEmpty() || label.equals("-")) continue;
				
				// Now update count of individual labels
				if( countRegexLabel.containsKey(label)){
					countRegexLabel.get(label).incrementAndGet();
				}
				else{
					countRegexLabel.put(label, new AtomicInteger(1));
				}
				
				// Now check if the labels are correctly tagged i.e match with input labels
				if( inputLabelMap != null && inputLabelMap.containsKey(label)){
					// increase the count of sublabel's correct detected for individual label's precision/recall calculation
					if( countCorrectLabel != null && countCorrectLabel.containsKey(label)){
						countCorrectLabel.get(label).incrementAndGet();
					}
					else{
						countCorrectLabel.put( label, new AtomicInteger(1));
					}
				}
				else { // Unmatched sub labels are supposed to be printed to file.To keep track of incorrect entries
					labelRegexString.append(label + Constants.LABEL_DELIM);
				}
			}
		}
		labelRegexString.append( Constants.FIELD_DELIM );
		// Iterate over the unmatched labels of input string to create string
		Iterator<String> itr = inputLabelMap.keySet().iterator();
		while( itr.hasNext()){
			labelInputString.append(itr.next() + Constants.LABEL_DELIM);
		}
		labelInputString.append( Constants.FIELD_DELIM );
	}
	
	/**
	 * Update the count of total and correct sub labels detected by regex engine
	 * @param subCategory
	 * @param inputSubLabelMap
	 * @param subLabelInputString
	 * @param subLabelRegexString
	 */
	public void updateRegexSubLabelsCount( String subCategory, HashMap<String, Boolean> inputSubLabelMap, 
										   StringBuilder subLabelInputString, StringBuilder subLabelRegexString	){

		String sublabel21[]  = subCategory.split( Constants.LABEL_DELIM );
		if( sublabel21.length >= 1){
			for( int i=0; i<sublabel21.length; i++ ){
				String sublabel = sublabel21[i].trim();
				if( sublabel.isEmpty() || sublabel.equals("-")) continue;
				totDetected++;  // total sub-labels detected by regex for overall precision calculation
				// Now update count of individual sub labels
				if( countRegexSublabel.containsKey(sublabel)){
					countRegexSublabel.get(sublabel).incrementAndGet();
				}
				else{
					countRegexSublabel.put(sublabel, new AtomicInteger(1));
				}

				// Now check if the sub-labels are correctly tagged i.e match with input labels
				if( inputSubLabelMap != null && inputSubLabelMap.containsKey(sublabel)){
					correctDetected++;  					// Increase the correct count.
					inputSubLabelMap.remove(sublabel);	//Remove the sublabel from input map
					
					// increase the count of sublabel's correct detected for individual label's precision/recall calculation
					if( countCorrectSublabel != null && countCorrectSublabel.containsKey(sublabel)){
						countCorrectSublabel.get(sublabel).incrementAndGet();
						
					}
					else{
						countCorrectSublabel.put( sublabel, new AtomicInteger(1));
					}
				}
				else { // Unmatched sub labels are supposed to be printed to file.To keep track of incorrect entries
						subLabelRegexString.append(sublabel  + Constants.LABEL_DELIM ) ;
				}
				subLabelRegexString.append( Constants.FIELD_DELIM ) ;
			}
		}
		// Iterate over the unmatched labels of input string to create string
		Iterator<String> itr = inputSubLabelMap.keySet().iterator();
		while( itr.hasNext()){
			subLabelInputString.append( itr.next() + Constants.LABEL_DELIM);
		}
		subLabelInputString.append( Constants.FIELD_DELIM );
	}
	
	/**
	 * Calculate precision and recall of sub-labels
	 * @param bw
	 * @throws IOException
	 */
	public void calculatePrecisionRecall( BufferedWriter bw  ) throws IOException{
    	bw.write("\n\n\n\n");
		bw.write( " **********************************PRECISION RECALL FOR SUBLABELS ********************************** " + "\n");
		Iterator<String> itr = countInputSublabel.keySet().iterator();
	    double recall    = 0.0; 
	    double precision = 0.0; 
	    while( itr.hasNext()){
	    	String sublabel = itr.next();
	    	double countTotal, countDetected, countCorrect;
	    	countTotal  = countDetected  = countCorrect  = 0 ;
	    	// Get precision recall for sublabels
	    	countTotal    = countInputSublabel.containsKey(sublabel)   ? countInputSublabel.get(sublabel).get()   : 0.0;
	    	countDetected = countRegexSublabel.containsKey(sublabel)   ? countRegexSublabel.get(sublabel).get()   : 0.0;
	    	countCorrect  = countCorrectSublabel.containsKey(sublabel) ? countCorrectSublabel.get(sublabel).get() : 0.0;
	    	if( countDetected != 0 && countTotal != 0 ){
	    		precision  = countCorrect/countDetected;
	    		recall     = countCorrect/countTotal;
	    	}
	    	// Okay now write this also to file
	    	bw.write(  sublabel + Constants.FIELD_DELIM + precision  + Constants.FIELD_DELIM + recall  + "\n" );
	    	System.out.println(sublabel + Constants.FIELD_DELIM + precision + Constants.FIELD_DELIM + recall + "\n");
	    }
	}

	/**
	 * Calculate precision and recall of labels
	 * @param bw
	 * @throws IOException
	 */
	public void calculatePrecisionRecallL( BufferedWriter bw  ) throws IOException{
		bw.write("\n\n\n\n");
    	bw.write( " **********************************PRECISION RECALL FOR LABELS ********************************** " + "\n"); 
		Iterator<String> itr = countInputLabel.keySet().iterator();
	    double recall    = 0.0; 
	    double precision = 0.0; 
	    while( itr.hasNext()){
	    	String label = itr.next();
	    	double countTotal, countDetected, countCorrect;
	    	countTotal  = countDetected  = countCorrect  = 0 ;
	    	// Get precision recall for sublabels
	    	countTotal    = countInputLabel.containsKey(label)   ? countInputLabel.get(label).get()         : 0.0;
	    	countDetected = countRegexLabel.containsKey(label)   ? countRegexLabel.get(label).get()   		: 0.0;
	    	countCorrect  = countCorrectLabel.containsKey(label) ? countCorrectLabel.get(label).get() 		: 0.0;
	    	if( countDetected != 0 && countTotal != 0 ){
	    		precision  = countCorrect/countDetected;
	    		recall     = countCorrect/countTotal;
	    	}
	    	// Okay now write this also to file
	    	bw.write(  label + Constants.FIELD_DELIM + precision  + Constants.FIELD_DELIM + recall  + "\n" );
	    	System.out.println( label + Constants.FIELD_DELIM + precision + Constants.FIELD_DELIM + recall + "\n");
	    }
	}

	
	/**
	 * Takes two files as arguments and compute precision/recall.
	 * Also writes to a file sentence tagged wrongly.
	 * 1st part contains the actual sentence.
	 * 2nd part contains either 'Y' or 'emotion' denoting whether distortion present or not
	 * 3rd part contains ',' separated values of labels
	 * 4th part contains ',' separated values of sub-labels
	 */
	
	// ToDo : One MARATHON function. Need to chop it down. Cut! cut! cut!
	public void compareResults( String inputFile, String regexOutputFile, String resultFile ){
		
		BufferedReader br1, br2; br1 = br2 = null;
		BufferedWriter bw =  null;
	    String line1, line2; line1 = line2 = "";
	    try{
		    br1 = new BufferedReader(new FileReader(new File(inputFile)));
		    br2 = new BufferedReader(new FileReader(new File(regexOutputFile)));
		    bw =  new BufferedWriter(new FileWriter(new File(resultFile)));
		    while(( line1 = br1.readLine()) != null ){
		    	line2 = br2.readLine() != null ? br2.readLine() : "";
			    HashMap<String,Boolean> inputSubLabelMap = new HashMap<String,Boolean>();
			    HashMap<String, Boolean> inputLabelMap   = new HashMap<String,Boolean>(); 

				// Split the line. And extract corresponding parts 
		    	String arr1[] = line1.split( Constants.FIELD_DELIM );
				String arr2[] = line2.split( Constants.FIELD_DELIM );
				String sentence1     = arr1.length > 0 ? arr1[0] : "";
				String sentence2     = arr2.length > 0 ? arr2[0] : "";
				String isDistortion1 = arr1.length > 1 ? arr1[1] : "";
				String isDistortion2 = arr2.length > 1 ? arr2[1] : "";
				String label1        = arr1.length > 2 ? arr1[2] : "";
				String label2        = arr2.length > 2 ? arr2[2] : "";
				String subCategory1  = arr1.length > 3 ? arr1[3] : "";
				String subCategory2  = arr2.length > 3 ? arr2[3] : "";
				
				// update labels and sub-labels input count
				updateInputLabelsCount(label1, inputLabelMap);
				updateInputSubLabelsCount(subCategory1, inputSubLabelMap);
				
				StringBuilder subLabelRegexString = new StringBuilder();
				StringBuilder subLabelInputString = new StringBuilder();
				
				StringBuilder labelInputString = new StringBuilder();
				StringBuilder labelRegexString = new StringBuilder();
				
				// update the labels and sub-labels regex and correct count
				updateRegexLabelsCount(label2, inputLabelMap, labelInputString, labelRegexString  );
				updateRegexSubLabelsCount(subCategory2, inputSubLabelMap, subLabelInputString, subLabelRegexString );
				
				// Finally Print the unmatched parts of sentence into file
				bw.write( sentence1 + Constants.OUTPUT_FIELD_DELIM + isDistortion1 + Constants.OUTPUT_FIELD_DELIM + isDistortion2
						+  label1 + Constants.OUTPUT_FIELD_DELIM + label2 + Constants.OUTPUT_FIELD_DELIM 
						+  subLabelInputString.toString() + Constants.OUTPUT_FIELD_DELIM +  subLabelRegexString  + "\n" );
				// Make GC's life easier. set everything null
				arr1   = null; arr2   = null; sentence1 = null; sentence2 = null; isDistortion1 = null; isDistortion2 = null;
				label1 = null; label2 = null; subCategory1 = null; subCategory2 = null;				
			}
		    // Finally the time to calculate Precision/ Recall
		    // Overall precision
		    if( totDetected != 0 && totSubLabels != 0) {
		    	precisionSubLabels = correctDetected/totDetected;
		    	recallSubLabels    = correctDetected/totSubLabels;
		    }
		    bw.write( "\n\n\n\n" );
		    bw.write(  "********************************** OVERALL PRECISION RECALL ********************************** " + "\n");
	    	bw.write(  "Overall" + Constants.FIELD_DELIM + precisionSubLabels + Constants.FIELD_DELIM + recallSubLabels  + "\n" );
	    	System.out.println("Overall" + Constants.FIELD_DELIM + precisionSubLabels + Constants.FIELD_DELIM + recallSubLabels + "\n" );
		    
	    	calculatePrecisionRecall(bw);	// Calculate for every sub label
	    	calculatePrecisionRecallL(bw);  // Calculate for every label
	    }
				
	    catch( Exception e){
	    	e.printStackTrace();
	    }
	    finally {
			try {
				if (br1 != null)br1.close();
				if (br2 != null)br2.close();
				if( bw != null)bw.close();
			} catch (IOException ex) {
				ex.printStackTrace();
			}
		}
	    
	}
	
	public static void main(String args[]){
		Process p = new Process();
		String inputFile = "/home/sanchit/Downloads/project/regex/labelled_thoughts.csv";
		String regexOutputFile = "/home/sanchit/Downloads/project/regex/regex_output.txt";
		String resultFile   = "/home/sanchit/Downloads/project/regex/result.txt";
		p.compareResults(inputFile, regexOutputFile, resultFile);
	}
	
}